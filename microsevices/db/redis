https://blog.csdn.net/weixin_44981707/article/details/115610686
1.使用领域：（用C写的引擎）
	快速的吞吐量的情况
2.特点
	1.Redis 是基于内存操作的，吞吐量非常高，可以在 1s内完成十万次读写操作
	2.Redis 的读写模块是单线程，每个操作都具原子性
	3.Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启可以再次加载，但可能会有极短时间内数据丢失
	4.Redis 支持多种数据结构，String，list，set，zset，hash等



3.数据结构
	1.String
	字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。Redis 的 string 可以包含任何数据，比如 jpg图片或者序列化的对象
	
	内部实现：本质为一个char*
	技巧：1.键值对操作
		 2.批量键值对：批量对多个字符串进行读写，节省时间
		 3.过期和set命令扩展：可以对key设置过期时间，到点自动删除，常用来控制缓存的失效时间
		 4.计数：如果value是一个整数，还可以对其自增，范围为signed long的最大最小值
	2.List
	本质为一个双向链表，当其弹出最后一个元素后，删除该链表Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符
串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
	3.Hash(字典)
	hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。
	hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。
	有这两种hash：
	1.ziplist：如果hash对象保存的键和值字符串长度都小于64字节且hash对象保存的键值对数量小于512，则采用这种
	数据量较小的时候，把所有的key和value当成一个元素，顺序地存入ziplist中，构成有序
	2.dict（字典）：其他情况采用这种数据结构，本质为一个value只能是string的unordered_map
	
	4.Set
	set 是一个无序的、自动去重的集合数据类型，Set 底层用两种数据结构存储
	intset：如果元素个数少于默认值512且元素可以用整型，则用这种数据结构
	dict（字典）：其他情况采用这种数据结构
	5.zset(有序集合)
	当元素比较少的时候，zset还是使用一个双向链表来存储数据，但是双向链表按照对应的score来进行排序
	当元素很多的时候，redis底层采用了skiplist的做法，也就是hash+skiplist,需要注意的是redis底层采用了指针的模式，所以并不会消耗多余的内存，注意到redis zset的查找时间复杂度为O(logn)这是由于其采用了多层链表的操作（类似二分查找）
	但是多层链表的话，每次插入都需要调整插入位置其后的元素，导致最终的时间复杂度仍旧为O(n),redis避免了这个问题
	具体做法为：每次新插入一个节点，随机生成一个大于等于1的数，代表其层数。

4.过期策略
	Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。
	那么对于过期的key，redis是怎么保证不会因为太多而误删漏删呢？
	1.过期key集合
	redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。
	2.定时扫描策略
	Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是
	采用了一种简单的贪心策略。
	1.从过期字典中随机 20 个 key；
	2.删除这 20 个 key 中已经过期的 key；
	3.如果过期的 key 比率超过 1/4，那就重复步骤 1；
  	同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。

5.内存淘汰机制
Redis 数据库可以通过配置文件来配置最大缓存，当写入的数据发现没有足够的内存可用的时候，Redis 会触发内存淘汰机制。Redis 为了满足多样化场景，提供了八种策略，可以在 redis.config 文件中配置。
	1.volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
	2.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
	3.volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
	4.volatile-lfu：从已设置过期时间的数据集中挑选使用频率最低的数据淘汰
	5.allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰
	6.allkeys-lfu：从所有数据集中挑选使用频率最低的数据淘汰
	7.allkeys-random：从所有数据集中任意选择数据淘汰
	8.noenviction：不回收任何数据，返回一个写操作的错误信息。这也是默认策略

6.redis持久化
	Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的持久化机制。
  	Redis 的持久化机制有两种，第一种是快照，第二种是 AOF 日志。快照是一次全量备份，AOF 日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录的是内存数据修改的指令记录文本。AOF 日志在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长。所以需要定期进行 AOF 重写，给 AOF 日志进行瘦身。
	1.快照原理

	