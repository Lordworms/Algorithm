这里用rocketmq来解释消息队列的作用：
	1.首先，消息队列是用于解耦，传统的做法是当某个服务产生消息后，就一个一个地调用对应的需要这个消息的服务，然后修改对应的数据，应用消息队列之后，我们的做法得到了改变，我们每个服务产生的消息，直接丢进消息队列中，然后给下游服务去取。
	2.其次，消息队列应用于异步操作，我们可以把原本的长链路调度修改为只修改必须要修改的部分，之后我们把剩下的异步操作信息存入消息队列，然后
可以降低响应时间
	3.第三个应用场景是用于多流量的时候，我们可以把输入的请求扔进消息队列，只处理服务能够处理完成的流量


消息队列的消息模型： 包括队列模型和发布/订阅模型
	1.队列模型
	这是最初的一种消息队列模型，对应着消息队列“发-存-收”的模型。生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，也就是说每条消息只能被一个消费者消费。
	2.发布订阅模型：解决了队列模型无法解决的：需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息 这个问题
	生产者把消息存入服务器的topic中
	这两种方式的本质相同，唯一的不同是：一份消息是否可以被多次消费





Rocketmq本身的消息由下面几部分构成：
	1.message：一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。
	2.topic：Topic（主题）可以看做消息的归类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。Topic 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅
	3.Tag：可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 Tag 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 Tag 。
	4.group：rocketmq中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。
	5.offset：
在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。也可以这么说，Queue 是一个长度无限的数组，Offset 就是下标。

消息的消费模式：集群消费和广播消费
1.集群消费
	默认情况是这种，这种模式下一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。
2.广播消费
	广播消费消息会发给消费者组中的每一个消费者进行消费。





rocketMQ的基本架构：包括1.Name Server 2.Broker 3.Producer 4.Consumer

1.Name Server
	NameServer 是一个无状态的服务器，角色类似于 Kafka使用的 Zookeeper，但比 Zookeeper 更轻量。
特点：
	每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。
	Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 	NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 	的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 	NameServer。
	功能主要有两个：
		1、和Broker 结点保持长连接。
		2、维护 Topic 的路由信息。

2. Broker
	消息存储和中转角色，负责存储和转发消息。
	Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。
	单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。

3.Producer
消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。
	Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。

	RocketMQ 提供了三种方式发送消息：同步、异步和单向
		同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。

		异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。

		单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。
4. Consumer
	消息消费者，负责消费消息，一般是后台系统负责异步消费。
	Consumer也由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消费，提供实时的消息订阅机制。
		Pull：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。
		Push：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push  称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push  首先要注册消费监听器，当监听器处触发后才开始消费消息。





进阶问题：
1.如何保证消息的可用性/可靠性/不丢失呢？
消息可能在哪些阶段丢失呢？可能会在这三个阶段发生丢失：生产阶段、存储阶段、消费阶段。
所以要从这三个阶段考虑：
	1.生产：在生产阶段，主要通过请求确认机制，来保证消息的可靠传递。
		1.同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。
		2.异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。
		3.如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。
	
	2.存储阶段：存储阶段，可以通过配置可靠性优先的 Broker 参数来避免因为宕机丢消息，简单说就是可靠性优先的场景都应该使用同步。
	1.消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。
	2.Broker的刷盘机制：同步刷盘和异步刷盘，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。
	
	3.消费阶段
	Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。

剩下的问题详见 https://blog.csdn.net/qq_19007169/article/details/124749936


	
	