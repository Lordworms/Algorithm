1.rpc（remote procedure call）
	不是通讯协议，而是一种设计、实现的框架，rpc要解决协议通讯问题，还有序列化和反序列化以及消息通知的问题。

2.一个完整的RPC架构中包含了四个核心的组件，分别为
	1.客户端：服务调用方
	2.服务端：服务提供方
	3.客户端存根：socket管理，网络首发包的序列化
	4.服务端存根：socket管理，提醒server层rpc方法调用，以及网络收发包的序列化

3.grpc
	gRPC是RPC的一种，它使用Protocol Buffer(简称Protobuf)作为序列化格式，Protocol Buffer是来自google的序列化框架，比Json更加轻便高效，同时基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。用protoc就能使用proto文件帮助我们生成上面的option层代码。
	适用场景：
	1.分布式场景 ：gRPC设计为低延迟和高吞吐量通信，非常适用于效率至关重要的轻型微服务。
	2.点对点实时通信： gRPC对双向流媒体提供出色的支持，可以实时推送消息而无需轮询。
	3.多语言混合开发 ：支持主流的开发语言，使gRPC成为多语言开发环境的理想选择。
	4.网络受限环境 ： 使用Protobuf（一种轻量级消息格式）序列化gRPC消息。gRPC消息始终小于等效的JSON消息。
	

4.rpc的四种调用方式
	1.单向rpc
	客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用
	2.服务流式rpc
	客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。
	3.客户端流式RPC
	客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答
	4.双向流式RPC
	即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持


5.grpc的每一层

	1.路由：和web框架的路由一致
	2.transport：编码、解码、分发，proto文件也在这里定义
	3.endpoint：请求操作，负责将transport传入的请求分发到service层，封装的作用
	4.service：提供的服务实现，有时候也只是个网关的作用
	5.domain，针对服务比较多的情形，如果服务比较少，那么服务写在service层，如果比较多
	写在domain层： domain层的内逻辑分别为：domain--> 子域-->聚合层-->repo--		>persisitence-->model

	